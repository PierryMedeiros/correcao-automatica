# .github/workflows/correction.yml

name: Correção Automática de Desafio

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'URL para clonagem (ex: https://.../repo.git)'
        required: true

jobs:
  correction-pipeline:
    runs-on: ubuntu-latest
    steps:
      # Passos 1 a 8 permanecem exatamente como no seu arquivo funcional
      - name: 1. Configurando ambiente Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - name: 2. Configurando PNPM
        uses: pnpm/action-setup@v3
        with:
          version: 8
      - name: 3. Clonando repositório do aluno
        id: clone_repo
        continue-on-error: true
        run: git clone ${{ github.event.inputs.repo_url }} .
      - name: 4. Feedback para Falha na Clonagem
        if: steps.clone_repo.outcome == 'failure'
        run: |
          echo "STATUS: REPROVADO (Erro no Repositório)"
          echo "Feedback: Olá! Não conseguimos acessar o seu repositório. Verifique se o link está correto e se o repositório está como 'Público' e tente novamente."
          exit 1
      - name: 5. Encontrando o diretório principal do projeto
        if: steps.clone_repo.outcome == 'success'
        id: find_project_dir
        run: |
          PROJECT_PATH=$(dirname $(find . -name "package.json" -print -quit))
          echo "path=$PROJECT_PATH" >> $GITHUB_OUTPUT
      - name: 6. Instalando dependências
        if: steps.clone_repo.outcome == 'success'
        working-directory: ${{ steps.find_project_dir.outputs.path }}
        run: |
          if [ -f pnpm-lock.yaml ]; then pnpm install;
          elif [ -f yarn.lock ]; then yarn install;
          elif [ -f package-lock.json ]; then npm ci;
          else npm install; fi
      - name: 7. Rodando testes unitários
        if: steps.clone_repo.outcome == 'success'
        id: run_tests
        working-directory: ${{ steps.find_project_dir.outputs.path }}
        continue-on-error: true
        run: npm test
      - name: 8. Feedback para Testes Falhos
        if: steps.clone_repo.outcome == 'success' && steps.run_tests.outcome == 'failure'
        run: |
          echo "STATUS: REPROVADO (Falha nos Testes)"
          echo "Feedback: Olá! Identificamos que um ou mais testes falharam. Lembre-se que todos os testes devem passar para o desafio ser aprovado. Revise a saída dos testes no log acima e envie novamente."
          exit 1
      
      # --- PASSO 9 TOTALMENTE REESCRITO PARA IMITAR O RACIOCÍNIO DO CLI ---
      - name: 9. Análise de Implementação com Contexto Completo
        if: steps.clone_repo.outcome == 'success' && steps.run_tests.outcome == 'success'
        id: gemini_analysis_and_process
        uses: actions/github-script@v7
        env:
          PROJECT_PATH: ${{ steps.find_project_dir.outputs.path }}
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const projectDir = process.env.PROJECT_PATH;
            process.chdir(projectDir);

            // 1. Coleta de todos os arquivos relevantes que a IA precisa
            let repoCode = '', interfaceCode = '', baseInterfaceCode = '', testCode = '';
            try {
              // Função auxiliar para ler arquivos, tratando o erro se não encontrar
              const readFileOrDefault = (command) => {
                try {
                  const path = execSync(command).toString().trim().split('\n')[0];
                  return path ? fs.readFileSync(path, 'utf8') : '';
                } catch (e) {
                  console.log(`Arquivo não encontrado com o comando: ${command}`);
                  return ''; // Retorna string vazia se o arquivo não for encontrado
                }
              };

              // Tenta encontrar e ler todos os arquivos que vimos no log do CLI
              repoCode = readFileOrDefault('find . -type f -name "*order.repository.ts" ! -name "*.spec.ts"');
              interfaceCode = readFileOrDefault('find . -type f -name "*order-repository.interface.ts"');
              baseInterfaceCode = readFileOrDefault('find . -type f -name "*repository-interface.ts" ! -name "*order-repository.interface.ts"');
              testCode = readFileOrDefault('find . -type f \\( -name "*order.repository.spec.ts" -o -name "*order.repository.test.ts" \\)');

              if (!repoCode || !interfaceCode) {
                core.setFailed('Não foi possível encontrar o arquivo da classe do repositório ou da interface principal.');
                return;
              }
            } catch (error) {
              core.setFailed(`Erro ao ler os arquivos do projeto: ${error.message}`);
              return;
            }
            
            // 2. Monta o prompt inspirado no raciocínio do CLI
            const prompt = `
              Você é um corretor de código sênior, especialista em DDD e TypeScript. Sua tarefa é analisar os arquivos de um projeto para verificar se a implementação de um repositório está completa.

              **Contexto do Projeto (Arquivos Relevantes):**

              --- ARQUIVO 1: A Interface Base (repository-interface.ts) ---
              \`\`\`typescript
              ${baseInterfaceCode || 'Não encontrado.'}
              \`\`\`

              --- ARQUIVO 2: A Interface Específica (order-repository.interface.ts) ---
              \`\`\`typescript
              ${interfaceCode}
              \`\`\`

              --- ARQUIVO 3: A Classe de Implementação (order.repository.ts) ---
              \`\`\`typescript
              ${repoCode}
              \`\`\`

              --- ARQUIVO 4: Os Testes (order.repository.spec.ts) ---
              \`\`\`typescript
              ${testCode || 'Não encontrado.'}
              \`\`\`

              **Sua Tarefa (Checklist):**
              1.  Combine os métodos da "Interface Base" e da "Interface Específica" para criar a lista completa de métodos necessários.
              2.  Verifique se a "Classe de Implementação" contém **todos** os métodos dessa lista completa.
              3.  Analise os "Testes" para ver se eles cobrem os métodos implementados.

              **Formato de Saída (JSON Obrigatório):**
              Preencha o JSON abaixo com sua análise.
              {
                "is_implementation_complete": <true_or_false>,
                "missing_methods": ["<liste aqui os nomes dos métodos faltantes, se houver>"],
                "final_status": "<APROVADO ou REPROVADO>",
                "feedback": "<Justifique sua decisão em um parágrafo, explicando o que está correto ou o que está faltando.>"
              }
            `;
            
            const apiKey = '${{ secrets.GOOGLE_API_KEY }}';
            const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=' + apiKey;
            
            const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }], "generationConfig": { "responseMimeType": "application/json" } }) });
            const data = await response.json();
            if (!response.ok || !data.candidates) { core.setFailed('Erro ao chamar a API do Gemini: ' + JSON.stringify(data)); return; }
            const jsonText = data.candidates[0].content.parts[0].text;
            const result = JSON.parse(jsonText);

            core.setOutput('status', result.final_status);
            core.setOutput('feedback', result.feedback);

      - name: 10. Exibindo Feedback Final
        if: steps.clone_repo.outcome == 'success' && steps.run_tests.outcome == 'success'
        env:
          STATUS: ${{ steps.gemini_analysis_and_process.outputs.status }}
          FEEDBACK: ${{ steps.gemini_analysis_and_process.outputs.feedback }}
        run: |
          echo "========================================="
          echo "O resultado da correção é: $STATUS"
          echo "========================================="
          echo "Feedback Final:"
          echo "$FEEDBACK"
          if [ "$STATUS" != "APROVADO" ]; then
            exit 1
          fi