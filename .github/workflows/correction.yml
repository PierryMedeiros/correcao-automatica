# .github/workflows/correction.yml

name: Correção Automática de Desafio (v5)

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'URL para clonagem (ex: https://.../repo.git)'
        required: true

jobs:
  correction-pipeline:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Configurando ambiente Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: 2. Configurando PNPM
        uses: pnpm/action-setup@v3
        with:
          version: 8

      - name: 3. Clonando repositório do aluno
        run: git clone ${{ github.event.inputs.repo_url }} .
      
      - name: 4. Instalando dependências
        run: |
          if [ -f pnpm-lock.yaml ]; then pnpm install;
          elif [ -f yarn.lock ]; then yarn install;
          elif [ -f package-lock.json ]; then npm ci;
          else npm install; fi

      - name: 5. Rodando testes unitários
        run: npm test
      
      - name: 6. Análise Personalizada com Gemini
        id: gemini_analysis_and_process
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // 1. Prepara contexto (árvore, código e agora os testes)
            try { execSync('sudo apt-get update && sudo apt-get install -y tree'); } catch (e) { console.log("Não foi possível instalar o tree."); }
            const folderStructure = execSync('tree -L 3 || echo "Erro ao gerar árvore."').toString();
            
            let repoPath, interfacePath, testPath;
            try {
              // Comandos 'find' aprimorados para serem mais flexíveis
              repoPath = execSync('find . -type f -name "*repository.ts" ! -name "*.interface.ts" ! -name "*.spec.ts" ! -name "*.test.ts"').toString().trim().split('\n')[0];
              interfacePath = execSync('find . -type f -name "*repository.interface.ts"').toString().trim().split('\n')[0];
              testPath = execSync('find . -type f \\( -name "*repository.spec.ts" -o -name "*repository.test.ts" \\)').toString().trim().split('\n')[0];
            } catch (error) {
              core.setFailed('Arquivos essenciais (repositório, interface ou teste) não encontrados.');
              return;
            }

            const repoCode = fs.readFileSync(repoPath, 'utf8');
            const interfaceCode = fs.readFileSync(interfacePath, 'utf8');
            const testCode = fs.readFileSync(testPath, 'utf8');
            
            // 2. Monta o NOVO PROMPT PERSONALIZADO
            const prompt = `
              Você é um Sênior Software Engineer e instrutor na Fullcycle, especialista em DDD e TypeScript. Sua tarefa é avaliar o desafio de um aluno, seguindo a mesma lógica de um corretor humano experiente, que é flexível com nomes mas rigoroso com conceitos.
              **REGRAS DE CORREÇÃO:**
              - **Seja flexível com nomes de arquivos e métodos.** O importante é a intenção. Por exemplo, \`findAll\`, \`getAll\`, e \`ProcurarTodos\` são todos válidos para a mesma operação de "buscar todos". \`order.repository.ts\` e \`OrderRepo.ts\` são nomes de arquivo aceitáveis. Reprove apenas por nomes muito ruins ou confusos.
              - **O critério principal é a aplicação correta dos conceitos** de DDD, TypeScript e a completude da solução.
              **CHECKLIST DE AVALIAÇÃO:**
              1.  **Estrutura de Pastas:** A estrutura do projeto separa claramente as responsabilidades, especialmente as camadas de \`domain\` e \`infrastructure\`?
              2.  **Implementação do Repositório:**
                  - Existe uma classe que funciona como um repositório (\`OrderRepository\`)?
                  - Essa classe implementa uma interface (\`OrderRepositoryInterface\`)?
                  - A classe contém métodos que cobrem as 4 lógicas essenciais: **criar, buscar um, buscar todos, e atualizar**?
              3.  **Cobertura de Testes:** Analisando os arquivos de teste, existem testes que validam as 4 operações (criar, buscar um, buscar todos, atualizar) do repositório?
              **Contexto do Projeto do Aluno:**
              (Aqui entrarão a estrutura de pastas e o conteúdo dos arquivos do aluno)
              **Formato de Saída (JSON Obrigatório):**
              Com base na sua análise, preencha o JSON abaixo.
              {
                "analysis_details": {
                  "folder_structure": { "is_correct": <true_or_false>, "feedback": "<Seu feedback sobre a estrutura de pastas>" },
                  "repository_implementation": { "is_correct": <true_or_false>, "feedback": "<Seu feedback sobre a implementação da classe e da interface>" },
                  "test_coverage": { "is_correct": <true_or_false>, "feedback": "<Seu feedback sobre a existência dos testes para as 4 operações>" }
                },
                "final_decision": {
                  "status": "<APROVADO, APROVADO_COM_RESSALVAS, ou REPROVADO>",
                  "justification": "<Um parágrafo de feedback final para o aluno, justificando o status com base nos pontos que você analisou. Seja construtivo e claro.>"
                }
              }
            `;
            
            const apiKey = '${{ secrets.GOOGLE_API_KEY }}';
            const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + apiKey;
            
            // 3. Chama a API do Gemini
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [{ parts: [{ text: prompt.replace("(Aqui entrarão a estrutura de pastas e o conteúdo dos arquivos do aluno)", `\n**Estrutura de Pastas:**\n\`\`\`\n${folderStructure}\`\`\`\n**Interface:**\n\`\`\`typescript\n${interfaceCode}\`\`\`\n**Repositório:**\n\`\`\`typescript\n${repoCode}\`\`\`\n**Testes:**\n\`\`\`typescript\n${testCode}\`\`\``) }] }],
                "generationConfig": { "responseMimeType": "application/json" }
              })
            });
            const data = await response.json();
            if (!response.ok || !data.candidates) { core.setFailed('Erro ao chamar a API do Gemini. Resposta: ' + JSON.stringify(data)); return; }
            const jsonText = data.candidates[0].content.parts[0].text;

            // 4. Processa o JSON e cria saídas com base na nova estrutura
            const result = JSON.parse(jsonText);
            const status = result.final_decision.status;
            const feedback = result.final_decision.justification;

            core.setOutput('status', status);
            core.setOutput('feedback', feedback);

      - name: 7. Exibindo Feedback Final Personalizado
        run: |
          STATUS='${{ steps.gemini_analysis_and_process.outputs.status }}'
          FEEDBACK='${{ steps.gemini_analysis_and_process.outputs.feedback }}'

          echo "========================================="
          echo "O resultado da correção é: $STATUS"
          echo "========================================="
          echo "Feedback da nossa IA:"
          echo "$FEEDBACK"

          # Falha o workflow se o status for REPROVADO para o ícone ficar vermelho
          if [ "$STATUS" = "REPROVADO" ]; then
            exit 1
          fi