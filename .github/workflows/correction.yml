# .github/workflows/correction.yml

name: Correção Automática de Desafio (v4 - Versão Final Robusta)

on:
  workflow_dispatch:
    inputs:
      repo_url:
        description: 'URL para clonagem (ex: https://.../repo.git)'
        required: true

jobs:
  correction-pipeline:
    runs-on: ubuntu-latest
    steps:
      - name: 1. Configurando ambiente Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: 2. Configurando PNPM
        uses: pnpm/action-setup@v3
        with:
          version: 8

      - name: 3. Clonando repositório do aluno
        run: git clone ${{ github.event.inputs.repo_url }} .
      
      - name: 4. Instalando dependências (com detecção automática)
        run: |
          if [ -f pnpm-lock.yaml ]; then pnpm install;
          elif [ -f yarn.lock ]; then yarn install;
          elif [ -f package-lock.json ]; then npm ci;
          else npm install; fi

      - name: 5. Rodando testes unitários
        run: npm test
      
      - name: 6. Análise e Processamento com Gemini
        id: gemini_analysis_and_process # O ID continua importante
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // 1. Prepara contexto (o mesmo de antes)
            try { execSync('sudo apt-get update && sudo apt-get install -y tree'); } catch (e) { console.log("Não foi possível instalar o tree."); }
            const folderStructure = execSync('tree -L 3 || echo "Erro ao gerar árvore de diretórios."').toString();
            let repoPath, interfacePath;
            try {
              repoPath = execSync('find . -type f -name "order.repository.ts"').toString().trim();
              interfacePath = execSync('find . -type f -name "order-repository.interface.ts"').toString().trim();
            } catch (error) { core.setFailed('Arquivos essenciais (order.repository.ts, etc.) não encontrados.'); return; }
            const repoCode = fs.readFileSync(repoPath, 'utf8');
            const interfaceCode = fs.readFileSync(interfacePath, 'utf8');
            
            // 2. Monta o prompt (o mesmo de antes)
            const prompt = `
              Você é um corretor de desafios da Fullcycle, especialista em DDD e TypeScript.
              **Tarefa:** Analise o projeto de um aluno com base nos critérios abaixo e retorne um JSON com sua avaliação.
              **Critérios de Análise:**
              1.  **Estrutura de Pastas DDD:** A estrutura de pastas segue boas práticas do DDD (camadas domain, infrastructure, etc.)?
              2.  **Implementação do Repository:** A classe 'OrderRepository' implementa a 'OrderRepositoryInterface' com a lógica para as quatro operações (create, find, findAll, update)?
              **Contexto do Projeto:**
              (Estrutura de pastas, código da interface e código do repositório)
              **Formato de Saída (JSON Obrigatório):**
              {
                "analysis": {
                  "ddd_folder_structure": { "is_correct": <true_or_false>, "feedback": "<Explique...>" },
                  "repository_implementation": { "is_correct": <true_or_false>, "feedback": "<Explique...>" }
                },
                "final_status": "<APROVADO ou REPROVADO>",
                "overall_feedback": "<Gere um feedback geral para o aluno em markdown...>"
              }
            `;
            
            const apiKey = '${{ secrets.GOOGLE_API_KEY }}';
            const url = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=' + apiKey;
            
            // 3. Chama a API do Gemini (o mesmo de antes)
            const response = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [{ parts: [{ text: prompt.replace("(Estrutura de pastas, código da interface e código do repositório)", `\n**Estrutura de Pastas:**\n\`\`\`${folderStructure}\`\`\`\n**Interface:**\n\`\`\`typescript\n${interfaceCode}\`\`\`\n**Repositório:**\n\`\`\`typescript\n${repoCode}\`\`\``) }] }],
                "generationConfig": { "responseMimeType": "application/json" }
              })
            });
            const data = await response.json();
            if (!response.ok || !data.candidates) { core.setFailed('Erro ao chamar a API do Gemini. Resposta: ' + JSON.stringify(data)); return; }
            const jsonText = data.candidates[0].content.parts[0].text;

            // --- ESTA É A MUDANÇA PRINCIPAL ---
            // 4. Processa o JSON e cria saídas simples
            const result = JSON.parse(jsonText);
            const status = result.final_status;
            const feedback = result.overall_feedback;

            console.log(`Status Decidido pela IA: ${status}`);
            console.log(`Feedback Gerado: ${feedback}`);

            // 5. Exporta as saídas de forma separada e simples
            core.setOutput('status', status);
            core.setOutput('feedback', feedback);

      # --- PASSOS FINAIS MUITO MAIS SIMPLES ---
      - name: 7. Exibindo Feedback Final
        run: |
          # Pega as saídas simples do passo anterior
          STATUS='${{ steps.gemini_analysis_and_process.outputs.status }}'
          FEEDBACK='${{ steps.gemini_analysis_and_process.outputs.feedback }}'

          echo "========================================="
          echo "O resultado da correção é: $STATUS"
          echo "========================================="
          echo "Feedback da nossa IA:"
          echo "$FEEDBACK"

          # Falha o workflow se o status não for APROVADO
          if [ "$STATUS" != "APROVADO" ]; then
            exit 1
          fi